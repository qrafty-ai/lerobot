---
phase: 01-pi-rl-recipe-foundation
plan: 02
type: execute
wave: 2
depends_on:
  - 01
files_modified:
  - src/lerobot/rl/learner.py
  - src/lerobot/rl/actor.py
  - src/lerobot/scripts/lerobot_train.py
  - src/lerobot/configs/train.py
autonomous: true
requirements:
  - RCP-01
  - RCP-02
must_haves:
  truths:
    - "User can run PI-RL recipe mode while keeping policy type as XVLA."
    - "Non-XVLA policies are blocked for PI-RL in Phase 1 before runtime starts."
    - "Actor and learner use one config path and fail hard on mismatch."
  artifacts:
    - path: src/lerobot/configs/train.py
      provides: recipe preflight helper(s) consumed by multiple entrypoints
    - path: src/lerobot/rl/learner.py
      provides: learner-side recipe startup guard
    - path: src/lerobot/rl/actor.py
      provides: actor-side recipe startup guard and shared-path enforcement
    - path: src/lerobot/scripts/lerobot_train.py
      provides: non-RL route remains stable when PI-RL is not selected
  key_links:
    - from: src/lerobot/rl/actor.py
      to: src/lerobot/rl/learner.py
      via: shared config and matching recipe preflight
      pattern: "config_path|recipe"
    - from: src/lerobot/configs/train.py
      to: src/lerobot/rl/actor.py
      via: common preflight function invocation
      pattern: "validate|preflight"
---

<objective>
Wire runtime recipe dispatch so PI-RL mode is policy-orthogonal and XVLA-gated.

Purpose: Ensure startup routing reflects Phase 1 constraints without changing policy taxonomy.
Output: Shared preflight checks in actor/learner/train entrypoints that enforce XVLA-only PI-RL eligibility and strict config consistency.
</objective>

<execution_context>
@/home/cc/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/cc/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-pi-rl-recipe-foundation/01-CONTEXT.md
@.planning/phases/01-pi-rl-recipe-foundation/01-RESEARCH.md
@src/lerobot/rl/actor.py
@src/lerobot/rl/learner.py
@src/lerobot/scripts/lerobot_train.py
@src/lerobot/configs/train.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add centralized PI-RL eligibility and startup summary preflight</name>
  <files>src/lerobot/configs/train.py, src/lerobot/rl/actor.py, src/lerobot/rl/learner.py</files>
  <action>Create one shared preflight routine that validates `recipe=pi-rl` is XVLA-only in Phase 1 per locked context decisions (future flow-matching expansion goes behind a capability flag in later phases), and prints a concise startup summary (recipe, policy, variant, config path) on valid configs. Keep output deterministic and concise for logs.</action>
  <verify>Run RL startup unit/integration tests that assert success with XVLA+PI-RL and failure with non-XVLA+PI-RL.</verify>
  <done>Runtime startup path has a single source of truth for eligibility checks and deterministic preflight output.</done>
</task>

<task type="auto">
  <name>Task 2: Enforce actor/learner config path consistency and hard-fail mismatch</name>
  <files>src/lerobot/rl/actor.py, src/lerobot/rl/learner.py, src/lerobot/configs/train.py</files>
  <action>Ensure both actor and learner expose/consume the same config path for recipe selection. Implement a concrete no-proto-change comparison mechanism over existing tensor payloads: compute `(resolved_config_path, normalized config hash)` in both processes; encode learner metadata into the first streamed state-dict payload as `torch.uint8` tensors (UTF-8 path bytes and hash bytes) under reserved keys; decode on actor side before accepting updates; compare with actor-local values. On mismatch, hard-fail with both decoded paths and both hashes in the error; do not silently continue.</action>
  <verify>Add tests that simulate mismatched actor/learner config paths and assert hard failure message contains both paths.</verify>
  <done>Any actor/learner recipe-source mismatch becomes a hard, explicit startup error.</done>
</task>

<task type="auto">
  <name>Task 3: Preserve non-PI-RL train script behavior and route PI-RL readiness cleanly</name>
  <files>src/lerobot/scripts/lerobot_train.py, src/lerobot/configs/train.py</files>
  <action>Keep existing non-RL/non-PI-RL training flow unchanged when recipe is unset. Add minimal routing hooks so PI-RL mode can be recognized without introducing `pi_rl` as a policy type or breaking current policy factory behavior.</action>
  <verify>Run existing train smoke tests plus a config-driven startup check confirming default path remains unchanged.</verify>
  <done>Recipe mode is orthogonal to policy type and existing train entrypoint behavior remains backward compatible.</done>
</task>

</tasks>

<verification>
- XVLA+PI-RL startup succeeds with preflight summary.
- Non-XVLA+PI-RL startup fails with allowed-policy guidance.
- Actor/learner config mismatch fails before runtime loops begin.
</verification>

<success_criteria>
- No new policy type introduced for PI-RL.
- Runtime route decision for PI-RL is centralized and testable.
- Default non-PI-RL flow remains untouched.
</success_criteria>

<output>
After completion, create `.planning/phases/01-pi-rl-recipe-foundation/01-02-SUMMARY.md`
</output>
